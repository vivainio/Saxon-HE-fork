<?xml version="1.0" encoding="UTF-8"?>
<test-catalog>
    <!-- Basic XSLT -->
    <test name="apply-templates-001" description="Basic apply-templates">
        <stylesheet>apply-templates-001.xsl</stylesheet>
        <source>apply-templates-001.xml</source>
        <expected>apply-templates-001.out</expected>
    </test>
    <test name="for-each-001" description="Basic for-each iteration">
        <stylesheet>for-each-001.xsl</stylesheet>
        <source>for-each-001.xml</source>
        <expected>for-each-001.out</expected>
    </test>
    <test name="for-each-group-001" description="Group by value">
        <stylesheet>for-each-group-001.xsl</stylesheet>
        <source>for-each-group-001.xml</source>
        <expected>for-each-group-001.out</expected>
    </test>
    <test name="variable-001" description="Variable declaration and use">
        <stylesheet>variable-001.xsl</stylesheet>
        <source>variable-001.xml</source>
        <expected>variable-001.out</expected>
    </test>
    <test name="function-001" description="User-defined function">
        <stylesheet>function-001.xsl</stylesheet>
        <source>function-001.xml</source>
        <expected>function-001.out</expected>
    </test>
    <test name="template-match-001" description="Template matching with predicates">
        <stylesheet>template-match-001.xsl</stylesheet>
        <source>template-match-001.xml</source>
        <expected>template-match-001.out</expected>
    </test>
    <test name="xpath-functions-001" description="XPath 3.1 functions">
        <stylesheet>xpath-functions-001.xsl</stylesheet>
        <source>xpath-functions-001.xml</source>
        <expected>xpath-functions-001.out</expected>
    </test>

    <!-- Control flow -->
    <test name="choose-001" description="xsl:choose/when/otherwise">
        <stylesheet>choose-001.xsl</stylesheet>
        <source>choose-001.xml</source>
        <expected>choose-001.out</expected>
    </test>
    <test name="sort-001" description="xsl:sort numeric">
        <stylesheet>sort-001.xsl</stylesheet>
        <source>sort-001.xml</source>
        <expected>sort-001.out</expected>
    </test>

    <!-- Keys and indexing -->
    <test name="key-001" description="xsl:key and key() function">
        <stylesheet>key-001.xsl</stylesheet>
        <source>key-001.xml</source>
        <expected>key-001.out</expected>
    </test>

    <!-- Copying and identity -->
    <test name="copy-001" description="Identity transform with filtering">
        <stylesheet>copy-001.xsl</stylesheet>
        <source>copy-001.xml</source>
        <expected>copy-001.out</expected>
    </test>

    <!-- Numbering -->
    <test name="number-001" description="xsl:number formatting">
        <stylesheet>number-001.xsl</stylesheet>
        <source>number-001.xml</source>
        <expected>number-001.out</expected>
    </test>

    <!-- Modes -->
    <test name="mode-001" description="Template modes">
        <stylesheet>mode-001.xsl</stylesheet>
        <source>mode-001.xml</source>
        <expected>mode-001.out</expected>
    </test>

    <!-- Dynamic construction -->
    <test name="attribute-001" description="xsl:element and xsl:attribute">
        <stylesheet>attribute-001.xsl</stylesheet>
        <source>attribute-001.xml</source>
        <expected>attribute-001.out</expected>
    </test>

    <!-- String analysis -->
    <test name="analyze-string-001" description="xsl:analyze-string regex">
        <stylesheet>analyze-string-001.xsl</stylesheet>
        <source>analyze-string-001.xml</source>
        <expected>analyze-string-001.out</expected>
    </test>

    <!-- XSLT 3.0: Maps and Arrays -->
    <test name="map-001" description="XPath 3.1 maps">
        <stylesheet>map-001.xsl</stylesheet>
        <source>map-001.xml</source>
        <expected>map-001.out</expected>
    </test>
    <test name="array-001" description="XPath 3.1 arrays">
        <stylesheet>array-001.xsl</stylesheet>
        <source>array-001.xml</source>
        <expected>array-001.out</expected>
    </test>

    <!-- XSLT 3.0: Error handling -->
    <test name="try-catch-001" description="xsl:try/catch error handling">
        <stylesheet>try-catch-001.xsl</stylesheet>
        <source>try-catch-001.xml</source>
        <expected>try-catch-001.out</expected>
    </test>

    <!-- XSLT 3.0: Iteration -->
    <test name="iterate-001" description="xsl:iterate with accumulator">
        <stylesheet>iterate-001.xsl</stylesheet>
        <source>iterate-001.xml</source>
        <expected>iterate-001.out</expected>
    </test>

    <!-- XSLT 3.0: JSON -->
    <test name="json-001" description="parse-json and map access">
        <stylesheet>json-001.xsl</stylesheet>
        <source>json-001.xml</source>
        <expected>json-001.out</expected>
    </test>

    <!-- XSLT 3.0: Text value templates -->
    <test name="text-value-template-001" description="expand-text with curly braces">
        <stylesheet>text-value-template-001.xsl</stylesheet>
        <source>text-value-template-001.xml</source>
        <expected>text-value-template-001.out</expected>
    </test>

    <!-- XSLT 3.0: Higher-order functions -->
    <test name="higher-order-001" description="for-each, filter, fold-left functions">
        <stylesheet>higher-order-001.xsl</stylesheet>
        <source>higher-order-001.xml</source>
        <expected>higher-order-001.out</expected>
    </test>

    <!-- XSLT 3.0: Accumulators -->
    <test name="accumulator-001" description="xsl:accumulator running total">
        <stylesheet>accumulator-001.xsl</stylesheet>
        <source>accumulator-001.xml</source>
        <expected>accumulator-001.out</expected>
    </test>

    <!-- XSLT 3.0: Dynamic evaluation -->
    <test name="evaluate-001" description="xsl:evaluate dynamic XPath">
        <stylesheet>evaluate-001.xsl</stylesheet>
        <source>evaluate-001.xml</source>
        <expected>evaluate-001.out</expected>
    </test>

    <!-- XSLT 3.0: Conditional output -->
    <test name="where-populated-001" description="xsl:where-populated">
        <stylesheet>where-populated-001.xsl</stylesheet>
        <source>where-populated-001.xml</source>
        <expected>where-populated-001.out</expected>
    </test>

    <!-- XSLT 3.0: Assertions -->
    <test name="assert-001" description="xsl:assert validation">
        <stylesheet>assert-001.xsl</stylesheet>
        <source>assert-001.xml</source>
        <expected>assert-001.out</expected>
    </test>

    <!-- XSLT 3.0: Context item declaration -->
    <test name="context-item-001" description="xsl:context-item type declaration">
        <stylesheet>context-item-001.xsl</stylesheet>
        <source>context-item-001.xml</source>
        <expected>context-item-001.out</expected>
    </test>

    <!-- XSLT 3.0: Modular stylesheets -->
    <test name="include-001" description="xsl:include with functions and templates">
        <stylesheet>include-001.xsl</stylesheet>
        <source>include-001.xml</source>
        <expected>include-001.out</expected>
    </test>

    <!-- XSLT 3.0: Merge -->
    <test name="merge-001" description="xsl:merge sorted inputs">
        <stylesheet>merge-001.xsl</stylesheet>
        <source>merge-001.xml</source>
        <expected>merge-001.out</expected>
    </test>

    <!-- XSLT 3.0: Message -->
    <test name="message-001" description="xsl:message for debugging output">
        <stylesheet>message-001.xsl</stylesheet>
        <source>message-001.xml</source>
        <expected>message-001.out</expected>
    </test>

    <!-- XSLT 3.0: Next-match -->
    <test name="next-match-001" description="xsl:next-match template chaining">
        <stylesheet>next-match-001.xsl</stylesheet>
        <source>next-match-001.xml</source>
        <expected>next-match-001.out</expected>
    </test>

    <!-- XSLT 3.0: Break -->
    <test name="break-001" description="xsl:break early exit from iterate">
        <stylesheet>break-001.xsl</stylesheet>
        <source>break-001.xml</source>
        <expected>break-001.out</expected>
    </test>

    <!-- XSLT 3.0: On-empty and on-non-empty -->
    <test name="on-empty-001" description="xsl:on-empty and xsl:on-non-empty">
        <stylesheet>on-empty-001.xsl</stylesheet>
        <source>on-empty-001.xml</source>
        <expected>on-empty-001.out</expected>
    </test>

    <!-- XSLT 3.0: Sequence -->
    <test name="sequence-001" description="xsl:sequence returning values">
        <stylesheet>sequence-001.xsl</stylesheet>
        <source>sequence-001.xml</source>
        <expected>sequence-001.out</expected>
    </test>

    <!-- XSLT 3.0: Namespace -->
    <test name="namespace-001" description="xsl:namespace dynamic creation">
        <stylesheet>namespace-001.xsl</stylesheet>
        <source>namespace-001.xml</source>
        <expected>namespace-001.out</expected>
    </test>

    <!-- XSLT 3.0: Processing-instruction and comment -->
    <test name="pi-comment-001" description="xsl:processing-instruction and xsl:comment">
        <stylesheet>pi-comment-001.xsl</stylesheet>
        <source>pi-comment-001.xml</source>
        <expected>pi-comment-001.out</expected>
    </test>

    <!-- XSLT 3.0: Version check and error handling -->
    <test name="fallback-001" description="system-property version check with try/catch">
        <stylesheet>fallback-001.xsl</stylesheet>
        <source>fallback-001.xml</source>
        <expected>fallback-001.out</expected>
    </test>

    <!-- XSLT 3.0: Character maps -->
    <test name="character-map-001" description="xsl:character-map substitution">
        <stylesheet>character-map-001.xsl</stylesheet>
        <source>character-map-001.xml</source>
        <expected>character-map-001.out</expected>
    </test>

    <!-- XSLT 3.0: Shadow attributes -->
    <test name="shadow-attr-001" description="Shadow attributes (_attr syntax)">
        <stylesheet>shadow-attr-001.xsl</stylesheet>
        <source>shadow-attr-001.xml</source>
        <expected>shadow-attr-001.out</expected>
    </test>

    <!-- XSLT 3.0: Output options -->
    <test name="output-001" description="xsl:output CDATA and serialization">
        <stylesheet>output-001.xsl</stylesheet>
        <source>output-001.xml</source>
        <expected>output-001.out</expected>
    </test>
</test-catalog>
